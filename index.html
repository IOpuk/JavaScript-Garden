<!DOCTYPE html><html lang="ru"><head><title>JavaScript Гарден</title><meta charset="utf-8"><meta name="description" content="Руководство по хитростям и трюкам JavaScript."><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="stylesheet" href="style/garden.css" media="all"><link rel="stylesheet" href="style/print.css" media="print"><!--[if lt IE 9]>
<script src="javascript/html5.js"></script>
<![endif]-->
</head><body><!-- Navigation--><nav id="nav_main"><div><ul><li><a href="/JavaScript-Garden/en" title="JavaScript Garden in English">en</a></li><li><a href="/JavaScript-Garden/es" title="JavaScript Garden es Español">es</a></li><li><a href="/JavaScript-Garden/fi" title="JavaScript-puutarha suomeksi">fi</a></li><li><a href="/JavaScript-Garden/ja" title="JavaScript Garden in Japanese">ja</a></li><li><a href="/JavaScript-Garden/ko" title="JavaScript Garden">ko</a></li><li><a href="/JavaScript-Garden/pl" title="JavaScript Garden - ogród JavaScript po polsku">pl</a></li><li class="active"><a href="/JavaScript-Garden/" title="JavaScript Гарден по-русски">ru</a></li><li><a href="/JavaScript-Garden/tr" title="JavaScript Garden Türkçe">tr</a></li><li><a href="/JavaScript-Garden/zh" title="JavaScript Garden 中文翻译">zh</a></li><li><a href="/JavaScript-Garden/zhtw" title="JavaScript Garden 繁體中文翻譯">zhtw</a></li></ul><a id="top" href="#intro" title="Back to top">#top</a><a id="hide_menu" class="tablet">Hide Menu</a></div><ul><li class="nav_intro"><h1><a href="#intro">Вступление</a></h1><ul><li><a href="#intro.authors">Авторы</a></li><li><a href="#intro.contributors">Участники</a></li><li><a href="#intro.hosting">Хостинг</a></li><li><a href="#intro.translators">Переводчики</a></li><li><a href="#intro.license">Лицензия</a></li></ul></li><li class="nav_object"><h1><a href="#object">Объекты</a></h1><ul><li><a href="#object.general">Объекты и их свойства</a></li><li><a href="#object.prototype">Великий Прототип</a></li><li><a href="#object.hasownproperty">Функция <code>hasOwnProperty</code></a></li><li><a href="#object.forinloop">Цикл <code>for in</code></a></li></ul></li><li class="nav_function"><h1><a href="#function">Функции</a></h1><ul><li><a href="#function.general">Про объявление функций и о выражениях с ними</a></li><li><a href="#function.this">Как работает <code>this</code></a></li><li><a href="#function.closures">Замыкания и ссылки</a></li><li><a href="#function.arguments">Объект <code>arguments</code></a></li><li><a href="#function.constructors">Конструктор</a></li><li><a href="#function.scopes">Области видимости и пространства имён</a></li></ul></li><li class="nav_array"><h1><a href="#array">Массивы</a></h1><ul><li><a href="#array.general">Перебор массивов и свойств объектов</a></li><li><a href="#array.constructor">Конструктор <code>Array</code></a></li></ul></li><li class="nav_types"><h1><a href="#types">Типы</a></h1><ul><li><a href="#types.equality">Равенство и сравнения</a></li><li><a href="#types.typeof">Оператор <code>typeof</code></a></li><li><a href="#types.instanceof">Оператор <code>instanceof</code></a></li><li><a href="#types.casting">Приведение типов</a></li></ul></li><li class="nav_core"><h1><a href="#core">Ядро</a></h1><ul><li><a href="#core.eval">Почему нельзя использовать <code>eval</code></a></li><li><a href="#core.undefined"><code>undefined</code> и <code>null</code></a></li><li><a href="#core.semicolon">Автоматическая вставка точек с запятой</a></li></ul></li><li class="nav_other"><h1><a href="#other">Другое</a></h1><ul><li><a href="#other.timeouts"><code>setTimeout</code> и <code>setInterval</code></a></li></ul></li><li class="nav_appendix"><h1><a href="#appendix">Пояснения</a></h1><ul><li><a href="#appendix.fromtranslators">От переводчиков</a></li></ul></li></ul></nav><!-- Mobile navigation--><nav id="nav_mobile"><a id="nav_prev_section" href="#">prev section<span class="nav_section_name">section name</span></a><a id="nav_next_section" href="#">next section<span class="nav_section_name">section name</span></a><a id="show_menu">show menu</a></nav><!-- Sections--><section id="intro"><!-- Introduction--><header id="intro.intro"><h1>Вступление</h1><div><p><strong>JavaScript Гарден</strong> — это постоянно обновляющаяся и растущая документация по самым заковыристым темам языка JavaScript. В ней вы найдёте советы о том, как избежать распространённых ошибок и предсказать появление тех или иных багов. В документации подробно освещены проблемы оптимизации и нерекомендуемые практики с которыми, продираясь к глубинам языка, могут столкнуться даже просвещённые JavaScript-программисты.</p>

<p>JavaScript Гарден <strong>не cтавит</strong> себе целью научить вас языку JavaScript. Вам понадобится реальный опыт работы с языком чтобы понимать темы, рассматриваемые в этом руководстве. Если вам требуется изучить основы языка, пожалуйста обратитесь к замечательному <a href="https://developer.mozilla.org/en/JavaScript/Guide">руководством</a> на сайте Mozilla Developer Network.</p></div></header><!-- Articles--><article id="intro.authors"><h2>Авторы</h2><div><p>Это руководство является результатом работы двух заядлых пользователей <a href="http://stackoverflow.com/">Stack Overflow</a>: <a href="http://stackoverflow.com/users/170224/ivo-wetzel">Иво Ветцель /Ivo Wetzel/</a> (автора текста) и <a href="http://stackoverflow.com/users/313758/yi-jiang">Чжан И Цзян /Zhang Yi Jiang/</a> (дизайнера).</p></div></article><article id="intro.contributors"><h2>Участники</h2><div><ul>
<li><a href="https://github.com/caio">Кайо Ромао /Caio Romão/</a> (проверка орфографии)</li>
<li><a href="https://github.com/blixt">Андреас Бликст /Andreas Blixt/</a> (проверка грамматики)</li>
</ul></div></article><article id="intro.hosting"><h2>Хостинг</h2><div><p>JavaScript Garden хостится на <a href="https://github.com/BonsaiDen/JavaScript-Garden">GitHub</a>, однако <a href="http://cramerdev.com/">Cramer Development</a> поддерживают наше зеркало на <a href="http://javascriptgarden.info/">JavaScriptGarden.info</a>.</p></div></article><article id="intro.translators"><h2>Переводчики</h2><div><ul>
<li><a href="http://shamansir.madfire.net/">&#39;shaman.sir&#39;</a></li>
<li><a href="http://anton.shevchuk.name/">Антон Шевчук</a></li>
<li><a href="http://nixsolutions.com/">Максим Лозовой</a></li>
<li><a href="http://nixsolutions.com/">Елена Пашкова</a></li>
</ul></div></article><article id="intro.license"><h2>Лицензия</h2><div><p>JavaScript Гарден распространяется под <a href="https://github.com/BonsaiDen/JavaScript-Garden/blob/next/LICENSE">лицензией MIT</a> и располагается на <a href="https://github.com/BonsaiDen/JavaScript-Garden">GitHub</a>. Если вы найдёте ошибку или опечатку, пожалуйста <a href="https://github.com/BonsaiDen/JavaScript-Garden/issues">сообщите нам о ней</a> или запросите права на загрузку в репозиторий. Кроме того, вы можете найти нас в <a href="http://chat.stackoverflow.com/rooms/17/javascript">комнате JavaScript</a> среди чатов Stack Overflow.</p></div></article></section><section id="object"><!-- Introduction--><header id="object.intro"><h1>Объекты</h1></header><!-- Articles--><article id="object.general"><h2>Объекты и их свойства</h2><div><p>В JavaScript все значения ведут себя как объекты, лишь за двумя исключениями — <a href="#core.undefined"><code>null</code></a> и <a href="#core.undefined"><code>undefined</code></a>.</p>

<pre><code>false.toString(); // &#39;false&#39;
[1, 2, 3].toString(); // &#39;1,2,3&#39;

function Foo(){}
Foo.bar = 1;
Foo.bar; // 1
</code></pre>

<p>Распростанено заблуждение, что числовые литералы нельзя использовать в роли объектов — оно неверно и зародилось из-за упущения в парсере JavaScript, благодаря которому применение <em>точечной нотации</em> к числу воспринимается им как литерал числа с плавающей точкой.</p>

<pre><code>2.toString(); // вызывает SyntaxError
</code></pre>

<p>Есть несколько способов обойти этот недостаток и любой из них подойдёт, если нужно добиться от числа поведения объекта:</p>

<pre><code>2..toString(); // вторая точка распознаётся корректно
2 .toString(); // обратите внимание на пробел перед точкой
(2).toString(); // двойка вычисляется заранее
</code></pre>

</div><div><h3>Объекты как хранилища данных</h3>

<p>Объекты в JavaScript могут использоваться и как <a href="http://ru.wikipedia.org/wiki/%D0%A5%D0%B5%D1%88-%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D0%B0"><em>хеш-таблицы</em></a>: подавляющей частью они состоят из именованных свойств (ключей), привязанных к значениям.</p>

<p>Используя объектный литерал — нотацию <code>{}</code> — можно создать простой объект. Новый объект <a href="#object.prototype">наследуется</a> от <code>Object.prototype</code> и не имеет <a href="#object.hasownproperty">собственных свойств</a>.</p>

<pre><code>var foo = {}; // новый пустой объект

// новый объект со свойством &#39;test&#39;, имеющим значение 12
var bar = {test: 12};
</code></pre>

</div><div><h3>Доступ к свойствам</h3>

<p>Получить доступ к свойствам объекта можно двумя способами: используя либо точечную нотацию, либо запись квадратными скобками.</p>

<pre><code>var foo = {name: &#39;kitten&#39;}
foo.name; // kitten
foo[&#39;name&#39;]; // kitten

var get = &#39;name&#39;;
foo[get]; // kitten

foo.1234; // SyntaxError
foo[&#39;1234&#39;]; // работает
</code></pre>

<p>Обе нотации идентичны по принципу работы, одна лишь разница в том, что использование квадратных скобок позволяет устанавливать свойства динамически и использовать такие имена свойств, какие в других случаях могли бы привести к синтаксической ошибке.</p>

</div><div><h3>Удаление свойств</h3>

<p>Единственный способ полностью удалить свойство у объекта — использовать оператор <code>delete</code>; устанавливая свойство в <code>undefined</code> или <code>null</code>, вы только заменяете связанное с ним <em>значение</em>, но не удаляете <em>ключ</em>.</p>

<aside>
  <p><strong>Замечание</strong> от перев.: Если ссылок на значение больше нет, то сборщиком мусора удаляется и само значение, но ключ объекта при этом всё так же имеет новое значение.</p>
</aside>

<pre><code>var obj = {
    bar: 1,
    foo: 2,
    baz: 3
};
obj.bar = undefined;
obj.foo = null;
delete obj.baz;

for(var i in obj) {
    if (obj.hasOwnProperty(i)) {
        console.log(i, &#39;&#39; + obj[i]);
    }
}
</code></pre>

<p>Приведённый код выведет две строки: <code>bar undefined</code> и <code>foo null</code> — на самом деле удалено было только свойство <code>baz</code> и посему только оно будет отсутствовать в выводе.</p>

</div><div><h3>Запись ключей</h3>

<pre><code>var test = {
    &#39;case&#39;: &#39;Я — ключевое слово, поэтому меня надо записывать строкой&#39;,
    delete: &#39;Я тоже ключевое слово, и меня&#39; // порождает SyntaxError
};
</code></pre>

<p>Ключи свойств объектов могут записываться как явно символами без кавычек, так и в виде закавыченных строк. В связи с другим упущением в парсере JavaScript, вышеприведённый код выбросит <code>SyntaxError</code> во всех версиях ранее ECMAScript 5.</p>

<p>Источником ошибки является факт, что <code>delete</code> — это <em>ключевое слово</em> и поэтому его <em>необходимо</em> записывать как <em>строчный литерал</em>, ради уверенности в том, что оно будет корректно опознано более старыми движками JavaScript.</p>

<p><em>От перев.:</em> И еще один пример в пользу строковой нотации, это относится к <a href="http://ru.wikipedia.org/wiki/JSON">JSON</a>:</p>

<pre><code>// валидный JavaScript и валидный JSON
{
    "foo": "oof",
    "bar": "rab"
}

// валидный JavaScript и НЕвалидный JSON
{
    foo: "oof",
    bar: "rab"
}
</code></pre></div></article><article id="object.prototype"><h2>Великий Прототип</h2><div><p>В JavaScript отсутствует классическая модель наследования — вместо неё используется <a href="http://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%82%D0%BE%D1%82%D0%B8%D0%BF%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5"><em>прототипная модель</em></a>.</p>

<p>Хоть её и часто причисляют к недостаткам JavaScript, на самом деле прототипная модель наследования <em>мощнее</em> классической. К примеру, поверх неё можно предельно легко реализовать классическое наследование, а попытки совершить обратное вынудят вас попотеть.</p>

<p>Из-за того, что JavaScript — практически единственный широко используемый язык с прототипным наследованием, придётся потратить некоторое время на осознание различий между этими двумя моделями.</p>

<p>Первое важное отличие заключается в том, что наследование в JavaScript выполняется с использованием так называемых  <em>цепочек прототипов</em>.</p>

<aside>
  <p><strong>Замечание:</strong> При использовании конструкции <code>Bar.prototype = Foo.prototype</code> оба объекта будут делить друг с другом <strong>один и тот же</strong> прототип. Так что изменение прототипа одного из объектов повлечёт за собой изменение прототипа другого и наоборот — вряд ли это то, чего вы ожидали.</p>
</aside>

<pre><code>function Foo() {
    this.value = 42;
}
Foo.prototype = {
    method: function() {}
};

function Bar() {}

// Установим значением прототипа Bar новый экземпляр Foo
Bar.prototype = new Foo();
Bar.prototype.foo = &#39;Hello World&#39;;

// Убедимся, что Bar является настоящим конструктором
Bar.prototype.constructor = Bar;

var test = new Bar() // создадим новый экземпляр bar

// Цепочка прототипов, которая получится в результате
test [instance of Bar]
    Bar.prototype [instance of Foo]
        { foo: &#39;Hello World&#39; }
        Foo.prototype
            { method: ... }
            Object.prototype
                { toString: ... /* и т.д. */ }
</code></pre>

<p>В приведённом коде объект <code>test</code> будет наследовать оба прототипа: <code>Bar.prototype</code> и <code>Foo.prototype</code>; следовательно, он будет иметь и доступ к функции <code>method</code>, которую мы определили в прототипе <code>Foo</code>. Также, у него есть доступ к свойству <code>value</code> <strong>одного уникального</strong> экземпляра <code>Foo</code>, который является его прототипом. Важно заметить, что <code>new Bar()</code> при вызове <strong>не создаёт</strong> новый экземпляр <code>Foo</code>, а повторно использует тот объект, который был установлен ему (<code>Bar</code>) в прототипе: таким образом, все новые экземпляры <code>Bar</code> будут иметь <strong>одно и то же</strong> свойство <code>value</code>.</p>

<aside>
  <p><strong>Замечание:</strong> Никогда <strong>не используйте</strong> конструкцию <code>Bar.prototype = Foo</code>, поскольку ссылка будет указывать не на прототип <code>Foo</code>, а на объект-функцию <code>Foo</code>. Из-за этого цепочка прототипов будет проходить через <code>Function.prototype</code>, а не через <code>Foo.prototype</code> и в результате чего функция <code>method</code> вообще не будет содержаться в цепочке прототипов.</p>
</aside>

</div><div><h3>Поиск свойств</h3>

<p>При обращении к какому-либо свойству объекта, JavaScript проходит <strong>вверх</strong> по цепочке прототипов этого объекта, пока не найдет свойство c запрашиваемым именем.</p>

<p>Если он достигнет верхушки этой цепочки (а именно <code>Object.prototype</code>), и при этом так и не найдёт указанное свойство, вместо него вернётся значение <a href="#core.undefined">undefined</a>.</p>

</div><div><h3>Свойство <code>prototype</code></h3>

<p>Тот факт, что свойство <code>prototype</code> используется языком для построения цепочек прототипов, даёт нам возможность присвоить <strong>любое</strong> значение этому свойству. Однако обычные примитивы, если назначать их в качестве прототипа, будут просто-напросто игнорироваться.</p>

<pre><code>function Foo() {}
Foo.prototype = 1; // никакого эффекта
Foo.prototype = {
    "foo":"bar"
}; // это сработает
</code></pre>

<p>Но присвоение объектов, как в примерах здесь и выше, сработает, и позволит вам динамически создавать цепочки прототипов.</p>

</div><div><h3>Производительность</h3>

<p>Поиск свойств, располагающихся относительно высоко по цепочке прототипов, может негативно сказаться на производительности, особенно в критических к ней местах кода. Если же мы попытаемся найти несуществующее свойство, то поиск будет осуществлён вообще по всей цепочке, со всеми вытекающими последствиями.</p>

<p>Вдобавок, при <a href="#object.forinloop">циклическом переборе</a> свойств объекта, будет обработано <strong>каждое</strong> свойство, существующее в цепочке прототипов.</p>

</div><div><h3>Расширение встроенных прототипов</h3>

<p>Часто встречается неверное применение прототипов — расширение прототипа <code>Object.prototype</code> или прототипов одного из встроенных объектов JavaScript.</p>

<p>Подобная практика нарушает принцип <em>инкапсуляции</em>, и имеет соответствующее название — <a href="http://en.wikipedia.org/wiki/Monkey_patch">monkey patching</a>. К сожалению, в основу многих широко распространенных фреймворков, например Prototype, положен принцип изменения базовых прототипов. На самом деле — до сих пор не известно разумных причин примешивать во встроенные типы <em>нестандартную функциональность</em>.</p>

<p><strong>Единственным</strong> оправданием для расширения встроенных прототипов может быть только воссоздание возможностей более новых движков JavaScript, например функции <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/forEach"><code>Array.forEach</code></a>, которая появилась в версии 1.6.</p>

</div><div><h3>Заключение</h3>

<p>Перед тем, как вы приступите к разработке сложных приложений на JavaScript с использованием прототипов, вы <strong>должны</strong> полностью осознать как работают прототипные цепочки, и как организовывать наследование на их основе. Также, помните о зависимости между длиной цепочек прототипов и производительностью — разрывайте их при необходимости. Кроме того — <strong>никогда</strong> не расширяйте прототипы встроенных объектов, если вы не делаете это для совместимости с новыми возможностями Javascript.</p></div></article><article id="object.hasownproperty"><h2>Функция <code>hasOwnProperty</code></h2><div><p>Если вам необходимо проверить, определено ли свойство у <em>самого объекта</em>, а <strong>не</strong> где-то в его <a href="#object.prototype">цепочке прототипов</a>, вы можете использовать метод <code>hasOwnProperty</code>, который все объекты наследуют от <code>Object.prototype</code>.</p>

<aside>
  <p><strong>Примечание:</strong> Для проверки существования свойства <strong>недостаточно</strong> проверять, эквивалентно ли оно <code>undefined</code>. Свойство может вполне себе существовать, но при этом ему может быть присвоено значение <code>undefined</code>.</p>
</aside>

<p><code>hasOwnProperty</code> — единственная функция в JavaScript, которая позволяет получить свойства объекта <strong>без обращения</strong> к цепочке его прототипов.</p>

<pre><code>// Подпортим Object.prototype
Object.prototype.bar = 1;
var foo = {goo: undefined};

foo.bar; // 1
&#39;bar&#39; in foo; // true

foo.hasOwnProperty(&#39;bar&#39;); // false
foo.hasOwnProperty(&#39;goo&#39;); // true
</code></pre>

<p>Только используя <code>hasOwnProperty</code> можно гарантировать правильный результат при переборе свойств объекта в циклах. И <strong>нет</strong> иного способа для отделения свойств, которые определены в <em>самом</em> объекте, а не где-либо в цепочке его прототипов.</p>

</div><div><h3><code>hasOwnProperty</code> как свойство</h3>

<p>JavaScript <strong>не</strong> резервирует свойство с именем <code>hasOwnProperty</code>. Так что, если есть потенциальная возможность, что объект может содержать свойство с таким именем, чтобы получить ожидаемый результат, требуется использовать <em>внешний</em> вариант функции <code>hasOwnProperty</code>.</p>

<pre><code>var foo = {
    hasOwnProperty: function() {
        return false;
    },
    bar: &#39;Да прилетят драконы&#39;
};

foo.hasOwnProperty(&#39;bar&#39;); // всегда возвращает false

// Используем метод hasOwnProperty пустого объекта
// и передаём foo в качестве this
({}).hasOwnProperty.call(foo, &#39;bar&#39;); // true

// Для этих целей также можно использовать функцию hasOwnProperty из прототипа Object
Object.prototype.hasOwnProperty.call(foo, &#39;bar&#39;); // true
</code></pre>

<p><em>От перев.:</em> Обратите внимание, что последний способ в примере не создаёт новых объектов</p>

</div><div><h3>Заключение</h3>

<p><strong>Единственным</strong> надёжным способом проверить существование свойства у объекта является использование метода <code>hasOwnProperty</code>. Рекомендуется использовать этот метод в <strong>любом</strong> <a href="#object.forinloop">цикле <code>for in</code></a> вашего проекта, дабы избежать потенциальных ошибок с неверным заимствованием свойств из <a href="#object.prototype">прототипов</a> встроенных объектов.</p></div></article><article id="object.forinloop"><h2>Цикл <code>for in</code></h2><div><p>Как и оператор <code>in</code>, цикл <code>for in</code> проходит по всей цепочке прототипов, обходя свойства объекта.</p>

<aside>
  <p><strong>Примечание:</strong> Цикл <code>for in</code> <strong>не</strong> обходит те свойства объекта, у которых внутренний атрибут <code>enumerable</code> установлен в <code>false</code>; как пример - свойство <code>length</code> у массивов</p>
</aside>

<pre><code>// Подпортим Object.prototype
Object.prototype.bar = 1;

var foo = {moo: 2};
for(var i in foo) {
    console.log(i); // печатает и bar и moo
}
</code></pre>

<p>Так как изменить поведение цикла <code>for in</code> как такового не представляется возможным, то для фильтрации нежелательных свойств объекта внутри этого цикла используется метод <a href="#object.hasownproperty"><code>hasOwnProperty</code></a> из <code>Object.prototype</code>.</p>

<aside>
  <p><strong>Примечание:</strong>  Цикл <code>for in</code> всегда обходит всю цепочку прототипов полностью: таким образом, чем больше прототипов (слоёв наследования) в цепочке, тем медленнее работает цикл.</p>
</aside>

</div><div><h3>Использование <code>hasOwnProperty</code> в качестве фильтра</h3>

<pre><code>// всё то же foo из примера выше
for(var i in foo) {
    if (foo.hasOwnProperty(i)) {
        console.log(i);
    }
}
</code></pre>

<p>Это единственно правильная версия использования такого цикла. За счёт использования <code>hasOwnProperty</code> будет выведено одно <strong>только</strong> свойство <code>moo</code>. Если же вы уберёте проверку <code>hasOwnProperty</code>, код станет нестабилен и, если кто-то позволил себе изменить прототипы встроенных типов, такие как <code>Object.prototype</code>, у вас возникнут непредвиденные ошибки.</p>

<p>Один из самых популярных фреймворков <a href="http://www.prototypejs.org/">Prototype</a> использует упомянутое расширение <code>Object.prototype</code> — и если вы его подключаете — ни в коем случае не забывайте использовать <code>hasOwnProperty</code> внутри всех циклов <code>for in</code> — иначе у вас гарантированно возникнут проблемы.</p>

</div><div><h3>Рекомендации</h3>

<p>Рекомендация одна — <strong>всегда</strong> используйте <code>hasOwnProperty</code>. Пишите код, который будет в наименьшей мере зависеть от окружения, в котором он будет запущен — не стоит гадать, расширял кто-то прототипы или нет и используется ли в нём та или иная библиотека.</p></div></article></section><section id="function"><!-- Introduction--><header id="function.intro"><h1>Функции</h1></header><!-- Articles--><article id="function.general"><h2>Про объявление функций и о выражениях с ними</h2><div><p>Функции в JavaScript являются объектами. Следовательно, их можно передавать и присваивать точно так же, как и любой другой объект. Популярным сбособом использования этого свойства является передача <em>анонимной функции</em> в качестве функции обратного вызова в некую другую функцию — к примеру, при описании асинхронных вызовов.</p>

</div><div><h3>Объявление <code>function</code></h3>

<pre><code>// всё просто и привычно
function foo() {}
</code></pre>

<p>В следующем примереб ещё перед запуском всего скрипта, для описанной функции <a href="#function.scopes">резервируется</a> переменная; за счёт этого она доступна <em>в любом месте</em> кода, вне зависимости от того, где она <em>определена</em> — даже если она вызывается заранее, перед её фактическим объявлением в коде (и сколь угодно задолго до такого определения).</p>

<pre><code>foo(); // сработает, т.к. функция будет создана до выполнения кода
function foo() {}
</code></pre>

</div><div><h3><code>function</code> как выражение</h3>

<pre><code>var foo = function() {};
</code></pre>

<p>В конце этого примера переменной <code>foo</code> присваивается безымянная <em>анонимная</em> функция.</p>

<pre><code>foo; // &#39;undefined&#39;
foo(); // вызовет TypeError
var foo = function() {};
</code></pre>

<p>Поскольку выражение с применением <code>var</code> <em>резервирует</em> имя переменной <code>foo</code> ещё до запуска кода, <code>foo</code> уже имеет некое значение во время его исполнения (отсутствует ошибка «<code>foo</code> is not defined»).</p>

<p>Но поскольку сами <em>присвоения</em> исполняются только непосредственно во время работы кода, <code>foo</code> по умолчанию будет иметь лишь значение <a href="#core.undefined"><code>undefined</code></a> (до обработки строки с определением функции).</p>

</div><div><h3>Выражения с именованными фунциями</h3>

<p>Существует еще один ньюанс, касающийся присваивания именованных функций:</p>

<pre><code>var foo = function bar() {
    bar(); // работает
}
bar(); // получим ReferenceError
</code></pre>

<p>Здесь фукнция <code>bar</code> не доступна во внешней области видимости, так как она используется только для присвоения переменной <code>foo</code>; однако, внутри <code>bar</code> она неожиданно оказывается доступна. Такое поведение связано с особенностью работы JavaScript с <a href="#function.scopes">разыменованием</a> - имя функции <em>всегда</em> доступно в локальной области видимости самой функции.</p></div></article><article id="function.this"><h2>Как работает <code>this</code></h2><div><p>В JavaScript зона ответственности специальной переменной <code>this</code> концептуально отличается от тех, за которые отвечает <code>this</code> в других языках программирования. Различают ровно <strong>пять</strong> сущностей, к которым в этом языке может быть привязана переменная <code>this</code>.</p>

</div><div><h3>1. Глобальная область видимости</h3>

<pre><code>this;
</code></pre>

<p>Когда мы используем <code>this</code> в глобальной области видимости, она просто ссылается на <em>глобальный</em> объект.</p>

</div><div><h3>2. Вызов функции</h3>

<pre><code>foo();
</code></pre>

<p>Внутри функции <code>this</code> ссылается на <em>глобальный</em> объект.</p>

<aside>
  <p><strong>Замечание касательно ES5:</strong> В strict-режиме <strong>отсутствует</strong> понятие глобальной видимости, поэтому <code>this</code> в этом случае будет иметь значение <code>undefined</code>.</p>
</aside>

</div><div><h3>3. Вызов метода</h3>

<pre><code>test.foo();
</code></pre>

<p>Внутри метода <code>this</code> ссылается на <code>test</code>.</p>

</div><div><h3>4. Вызов конструктора</h3>

<pre><code>new foo();
</code></pre>

<p>Если перед вызовом функции присутствует ключевое слово <code>new</code> то данная функция будет действовать как <a href="#function.constructors">конструктор</a>. Внутри такой функции <code>this</code> будет указывать на <em>новый созданный</em> <code>Object</code>.</p>

</div><div><h3>5. Переопределение <code>this</code></h3>

<pre><code>function foo(a, b, c) {}

var bar = {};
foo.apply(bar, [1, 2, 3]); // внутри foo массив развернётся в аргументы
foo.call(bar, 1, 2, 3); // аналогично: a = 1, b = 2, c = 3
</code></pre>

<p>Когда мы используем методы <code>call</code> или <code>apply</code> из <code>Function.prototype</code>, то внутри вызваемой функции <code>this</code> <strong>явным образом</strong> будет присвоено значение первого передаваемого параметра.</p>

<p>Исходя из этого, в предыдущем примере (строка с <code>apply</code>), правило №3 <em>«вызов метода»</em> <strong>не</strong> будет применёно, и <code>this</code> внутри <code>foo</code> будет присвоено <code>bar</code>.</p>

<aside>
  <p><strong>Замечание:</strong> <code>this</code> <strong>нельзя</strong> использовать внутри литералов <code>{}</code> (<code>Object</code>) для ссылки на сам объект. Т.е. если мы напишем <code>var obj = {me: this}</code>, то <code>me</code> не будет ссылаться на <code>obj</code>, поскольку <code>this</code> присваивается только по одному из пяти описанных правил.</p>
</aside>

</div><div><h3>Наиболее распространенные ловушки</h3>

<p>Хотя большинство из примеров ниже имеют смысл, первый из них можно причислить к упущениям в самом языке, поскольку он <strong>вообще</strong> не имеет практических применений.</p>

<pre><code>Foo.method = function() {
    function test() {
        // this ссылается на глобальный объект
    }
    test();
}
</code></pre>

<p>Распространено заблуждение о том, что <code>this</code> внутри <code>test</code> ссылается на <code>Foo</code>, но это совсем <strong>не так</strong>.</p>

<p>Для того, чтобы получить доступ к <code>Foo</code> внутри функции <code>test</code>, необходимо создать локальную переменную внутри <code>method</code>, которая и будет ссылаться на <code>Foo</code>.</p>

<pre><code>Foo.method = function() {
    var that = this;
    function test() {
        // Здесь используем that вместо this
    }
    test();
}
</code></pre>

<p>Подходящее имя для такой переменной — <code>that</code>, и его часто используют для ссылки на внешний <code>this</code>. В комбинациях с <a href="#function.closures">замыканиями</a> такая переменная может использоваться, чтобы «пробрасывать» <code>this</code> в глобальную область, или в любой другой объект.</p>

</div><div><h3>Присвоение методов</h3>

<p>Еще одной возможностью, которая могла бы работать, но <strong>не</strong> работает в <code>JavaScript</code>, является создание псевдонимов (алиасов) для методов, т.е. <strong>присвоение</strong> метода объекта переменной.</p>

<pre><code>var test = someObject.methodTest;
test();
</code></pre>

<p>Следуя первому правилу, <code>test</code> вызывается как обычная функция; следовательно <code>this</code> внутри него больше не ссылается на <code>someObject</code>.</p>

<p>Хотя позднее связывание <code>this</code> на первый взгляд может показаться не очень хорошей идеей, но на самом деле это именно то, благодаря чему работает <a href="#object.prototype">наследование прототипов</a>.</p>

<pre><code>function Foo() {}
Foo.prototype.method = function() {};

function Bar() {}
Bar.prototype = Foo.prototype;

new Bar().method();
</code></pre>

<p>В момент, когда будет вызван <code>method</code> нового экземляра <code>Bar</code>, <code>this</code> будет ссылаться на этот самый экземпляр.</p></div></article><article id="function.closures"><h2>Замыкания и ссылки</h2><div><p>Одним из самых мощных инструментов язка JavaScript считают возможность создавать <em>замыкания</em>. Это такой приём, когда новые области видимости (например, функций) <strong>всегда</strong> имеют доступ к внешней области, в которых они были объявлены. Собственно, единственный механизм создания областей видимости в JavaScript — это и есть <a href="#function.scopes">функции</a>: таким образом, объявляя функцию, вы автоматически реализуете замыкания. Или, другими словами: любая объявленная функция по умолчанию ведёт себя как замыкание.</p>

</div><div><h3>Эмуляция приватных переменных</h3>

<pre><code>function Counter(start) {
    var count = start;
    return {
        increment: function() {
            count++;
        },

        get: function() {
            return count;
        }
    }
}

var foo = Counter(4);
foo.increment();
foo.get(); // 5
</code></pre>

<p>В данном примере <code>Counter</code> возвращает <strong>два</strong> замыкания: функции <code>increment</code> и <code>get</code>. Обе эти функции сохраняют внутри себя <strong>ссылку</strong> на область видимости <code>Counter</code> и, соответственно, имеют свободный доступ к переменной <code>count</code> из этой самой области.</p>

</div><div><h3>Как работают приватные переменные</h3>

<p>Поскольку в JavaScript нельзя присваивать или ссылаться на области видимости, заполучить <code>count</code> извне — <strong>не</strong> представляется возможным. Единственный способ взаимодействовать с этой переменной — изменять её внутри двух описанных замыканий.</p>

<pre><code>var foo = new Counter(4);
foo.hack = function() {
    count = 1337;
};
</code></pre>

<p>В приведенном примере мы <strong>не</strong> изменяем переменную <code>count</code> из области видимости <code>Counter</code>, т.к. <code>foo.hack</code> не объявлен в <strong>той</strong> области. Вместо этого будет создана или перезаписана <em>глобальная</em> переменная <code>count</code> (&#39;&#39;прим. перев.&#39;&#39; — замена кода внутри <code>foo.hack</code> на <code>this.count = 1337</code>, не поможет, конечно же, тоже, поскольку <code>count</code> и не был свойством объекта <code>Counter</code>, а был лишь внутренней переменной);</p>

</div><div><h3>Замыкания внутри циклов</h3>

<p>Существует одна, довольно часто встречающаяся, ловушка — когда замыкания используют внутри циклов, передавая переменную индекса внутрь.</p>

<pre><code>for(var i = 0; i &lt; 10; i++) {
    setTimeout(function() {
        console.log(i);
    }, 1000);
}
</code></pre>

<p>Данный код <strong>не</strong> будет выводить числа с <code>0</code> до <code>9</code> — вместо этого число <code>10</code> будет выведено десять раз.</p>

<p><em>Анонимная</em> функция сохраняет лишь <strong>ссылку</strong> на <code>i</code>, и когда будет вызвана функция <code>console.log</code>, цикл <code>for</code> уже <em>закончит</em> свою работу — и поэтому в переменной <code>i</code> будет покоиться значение <code>10</code>.</p>

<p>Для получения желаемого результата необходимо создать <strong>копию</strong> переменной <code>i</code>.</p>

</div><div><h3>Обход проблемы со ссылкой</h3>

<p>Для того, чтобы скопировать значение индекса из цикла, лучше всего использовать другую <a href="#function.scopes">анонимную функцию</a> как обёртку.</p>

<pre><code>for(var i = 0; i &lt; 10; i++) {
    (function(e) {
        setTimeout(function() {
            console.log(e);
        }, 1000);
    })(i);
}
</code></pre>

<p>Анонимная функция-обертка вызвается сразу же, и в качестве первого аргумента получает индекс <code>i</code>, <strong>значение</strong> которого будет скопировано в параметр <code>e</code>.</p>

<p>Анонимная функция, которая передается в <code>setTimeout</code>, теперь содержит ссылку на переменную <code>e</code>, значение которой <strong>не</strong> изменяется циклом.</p>

<p>Этот приём можно реализовать и другим способом — возвратив нужную функции из анонимной функции-обертки — поведение такого кода будет идентично поведению кода из предыдущего примера.</p>

<pre><code>for(var i = 0; i &lt; 10; i++) {
    setTimeout((function(e) {
        return function() {
            console.log(e);
        }
    })(i), 1000)
}
</code></pre>

<p>&#39;&#39;Прим, перев.&#39;&#39; В качестве упражнения на замыкания и анонимные функции, попробуйте заменить оборачивающие вызовы анонимных функций на варианты с <code>.call</code> и <code>.apply</code>.</p>

<aside>
  <p><strong>Замечание</strong> от перев. Переменную <code>e</code> можно тоже назвать <code>i</code>, если вы хотите: это не поменяет поведения кода — внутренняя переменная <code>i</code> всё так же будет <em>копией</em> внешней переменной.</p>
</aside></div></article><article id="function.arguments"><h2>Объект <code>arguments</code></h2><div><p>В области видимости любой функции в JavaScript есть доступ к специальной переменной <code>arguments</code>. Эта переменная содержит в себе список всех аргументов, переданных данной функции.</p>

<aside>
  <p><strong>Замечание:</strong> В случае, если переменная <code>arguments</code> уже была объявлена в области видимости функции либо путём присвоения через выражение <code>var</code>, либо являясь формальным параметром, объект <code>arguments</code> не будет создан.</p>
</aside>

<p>Объект <code>arguments</code> <strong>не</strong> является ни экземпляром, ни наследником <code>Array</code>. Он, конечно же, очень похож на массив, и даже содержит свойство <code>length</code> — но он не наследует <code>Array.prototype</code>, и если внимательно присмотреться, он окажется обычным <code>Object</code>.</p>

<p>По этой причине, у объекта <code>arguments</code> <strong>отсутствуют</strong> стандартные методы массивов, такие как <code>push</code>, <code>pop</code> или <code>slice</code>. Пусть перебор с использованием обычного цикла <code>for</code> по аргументам работает вполне корректно, но вам придётся конвертировать этот объект в настоящий массив типа <code>Array</code>, чтобы применять к нему стандартные методы массивов.</p>

</div><div><h3>Конвертация в массив</h3>

<p>Этот код вернёт новый массив типа <code>Array</code>, содержащий все элементы объекта <code>arguments</code>.</p>

<pre><code>Array.prototype.slice.call(arguments);
</code></pre>

<p>Будьте внимательны — это преобразование занимает <strong>много времени</strong> и использовать его в чувствительных к производительности частях кода <strong>не рекомендуется</strong>.</p>

</div><div><h3>Передача аргументов</h3>

<p>Ниже представлен рекомендуемый способ передачи аргументов из одной функции в другую.</p>

<pre><code>function foo() {
    bar.apply(null, arguments);
}
function bar(a, b, c) {
    // делаем здесь что-нибудь
}
</code></pre>

<p>Другой трюк — использовать и <code>call</code> и <code>apply</code> вместе, чтобы создать отвязанную от объекта обёртку, выполняющуюся приемлемо быстро:</p>

<pre><code>function Foo() {}

Foo.prototype.method = function(a, b, c) {
    console.log(this, a, b, c);
};

// Создаём несвязанную версию метода
// Она принимает параметры: this, arg1, arg2...argN
Foo.method = function() {

    // Результат: Foo.prototype.method.call(this, arg1, arg2... argN)
    Function.call.apply(Foo.prototype.method, arguments);

};
</code></pre>

</div><div><h3>Формальные аргументы и индексы аргументов</h3>

<p>Объект <code>arguments</code> создаёт по одному <em>геттеру</em> и по одному <em>сеттеру</em> как для всех своих свойств, так и для формальных параметров функции.</p>

<p>В результате, изменение формального параметра повлечёт за собой изменение значения соответствующего свойства объекта <code>arguments</code> и наоборот.</p>

<pre><code>function foo(a, b, c) {
    arguments[0] = 2;
    a; // 2

    b = 4;
    arguments[1]; // 4

    var d = c;
    d = 9;
    c; // 3
}
foo(1, 2, 3);
</code></pre>

</div><div><h3>Мифы и истина о производительности</h3>

<p>Объект <code>arguments</code> создаётся во всех случаях, лишь одним исключением — когда он переопределён по имени внутри функции или когда одним из её параметров является переменная с таким именем. Неважно, используется при этом сам объект в коде функции или нет.</p>

<p><em>Геттеры</em> и <em>сеттеры</em> создаются <strong>всегда</strong>; так что их использование практически никак не влияет на производительность, и тем более никак не влияет на неё в реальном коде, где обычно происходят вещи поважнее обычных прочтений и переопределений свойств объекта <code>arguments</code>.</p>

<aside class="es5"><p><strong>ES5 Замечание:</strong> Эти <em>геттеры</em> и <em>сеттеры</em> не создаются в strict-режиме.</p>
</aside>

<p>Однако, есть одна такая тайна, незнание которой автором кода может радикально понизить его производительность в современных движках JavaScript. Эта тайна — опасность использования <code>arguments.callee</code>.</p>

<pre><code>function foo() {
    arguments.callee; // сделать что-либо с этим объектом функции
    arguments.callee.caller; // и с вызвавшим его объектом функции
}

function bigLoop() {
    for(var i = 0; i &lt; 100000; i++) {
        foo(); // должна была бы «развернуться»
    }
}
</code></pre>

<p>В коде выше, функция <code>foo</code> не может <a href="http://en.wikipedia.org/wiki/Inlining">быть «развёрнута»</a> (а могла бы), потому что для корректной работы ей необходима ссылка и на себя и на вызвавший её объект. Такой код не только кладёт на лопатки механизм развёртывания, но и нарушает принцип инкапсуляции, поскольку функция становится зависима от конкретного контекста вызова.</p>

<p><strong>Крайне не рекомендуется</strong> использовать <code>arguments.callee</code> или какое-либо из его свойств. <strong>Никогда</strong>.</p>

<aside class="es5"><p><strong>ES5 Замечание:</strong> В strict-режиме любое использование <code>arguments.callee</code> вызовет <code>TypeError</code>, поскольку свойство принято устаревшим.</p>
</aside></div></article><article id="function.constructors"><h2>Конструктор</h2><div><p>Конструкторы в JavaScript тоже действуют отличным от большинства других языков образом. Любая функция, вызванная с использованием ключевого слова <code>new</code>, станет конструктором.</p>

<p>Внутри конструктора (вызываемой функции) <code>this</code> будет указывать на новосозданный <code>Object</code>. <a href="#object.prototype">Прототипом</a> этого <strong>нового</strong> экземпляра будет <code>prototype</code> функции, которая была вызвана под видом конструктора.</p>

<p>Если вызываемая функция не возвращает явного значения посредством <code>return</code>, то она автоматически вернёт <code>this</code> — тот самый новый экземпляр.</p>

<pre><code>function Foo() {
    this.bla = 1;
}

Foo.prototype.test = function() {
    console.log(this.bla);
};

var test = new Foo();
</code></pre>

<p>В этом примере <code>Foo</code> вызывается в виде конструктора, следовательно прототип созданного объекта будет привязан к <code>Foo.prototype</code>.</p>

<p>В случае, когда функция в явном виде возвращает некое значение используя <code>return</code>, в результате выполнения конструктора мы получим именно его, <strong>но только</strong> если возвращаемое значение представляет собой <code>Object</code>.</p>

<pre><code>function Bar() {
    return 2;
}
new Bar(); // новый объект

function Test() {
    this.value = 2;

    return {
        foo: 1
    };
}
new Test(); // возвращённый объект
</code></pre>

<p>Если же опустить ключевое слово <code>new</code>, то функция <strong>не</strong> будет возвращать никаких объектов.</p>

<pre><code>function Foo() {
    this.bla = 1; // свойство bla устанавливается глобальному объекту
}
Foo(); // возвращает undefined
</code></pre>

<p>Хотя этот пример и будет работать — в связи с поведением <a href="#function.this"><code>this</code></a> в JavaScript, значение будет присвоено <em>глобальному объекту</em> — навряд ли это предполагалось автором.</p>

</div><div><h3>Фабрики</h3>

<p>Если вы хотите предоставить возможность опускать оператор <code>new</code> при создании объектов, возвращайте из соответствующего конструктора явное значение посредством <code>return</code>.</p>

<pre><code>function Bar() {
    var value = 1;
    return {
        method: function() {
            return value;
        }
    }
}
Bar.prototype = {
    foo: function() {}
};

new Bar();
Bar();
</code></pre>

<p>В обоих случаях при вызове <code>Bar</code> мы получим один и тот же результат — новый объект со свойством <code>method</code>, являющимся <a href="#function.closures">замыканием</a>).</p>

<p>Ещё следует заметить, что вызов <code>new Bar()</code> никак <strong>не</strong> воздействует на прототип возвращаемого объекта. Хоть прототип и назначается всем новосозданным объектам, <code>Bar</code> никогда не возвращает этот новый объект (&#39;&#39;прим. перев.&#39;&#39; — судя по всему, подразумевается, что код <code>Bar</code> не может влиять на прототип созданного объекта, и под словами «новый объект» в последнем случае кроется прототип нового объекта, а не сам новый объект).</p>

<p>В предыдущем примере нет никаких функциональных различий между вызовом конструктора с оператором <code>new</code> и вызовом без него.</p>

</div><div><h3>Создание объектов с использованием фабрик</h3>

<p>Нередко встречаются советы <strong>не</strong> использовать оператор <code>new</code>, поскольку если вы его забудете, это может привести к ошибкам.</p>

<p>Чтобы создать новый объект, нам предлагают использовать фабрику и создать новый объект <em>внутри</em> этой фабрики.</p>

<pre><code>function Foo() {
    var obj = {};
    obj.value = &#39;blub&#39;;

    var private = 2;
    obj.someMethod = function(value) {
        this.value = value;
    }

    obj.getPrivate = function() {
        return private;
    }
    return obj;
}
</code></pre>

<p>Хотя данный пример и сработает, если вы забыли ключевое слово <code>new</code> и, возможно, благодаря ему вам станет легче работать с <a href="#function.closures">приватными переменными</a>, у него есть несколько недостатков:</p>

<ol>
<li>Он использует больше памяти, поскольку созданные объекты <strong>не</strong> хранят методы в прототипе и соответственно для каждого нового объекта создаётся копия каждого метода.</li>
<li>Чтобы эмулировать наследование, фабрике нужно скопировать все методы из другого объекта или установить прототипом нового объекта старый.</li>
<li>Разрыв цепочки прототипов по мнимой необходимости избавиться от использования ключевого слова <code>new</code> идёт вразрез с духом языка.</li>
</ol>

</div><div><h3>Заключение</h3>

<p>Хотя забытое ключевое слово <code>new</code> и может привести к багам, это точно <strong>не</strong> причина отказываться от использования прототипов. В конце концов, полезнее решить какой из способов лучше совпадает с требованиями приложения: крайне важно выбрать один из стилей создания объектов и после этого <strong>не изменять</strong> ему.</p></div></article><article id="function.scopes"><h2>Области видимости и пространства имён</h2><div><p>Хотя JavaScript вполне нормально воспринимает синтаксис двух сопоставимых фигурных скобок, окружающих блок, он <strong>не</strong> поддерживает блочную область видимости; всё что остаётся на этот случай в языке — <em>область видимости функций</em>.</p>

<pre><code>function test() { // область видимости
    for(var i = 0; i &lt; 10; i++) { // не область видимости
        // считаем
    }
    console.log(i); // 10
}
</code></pre>

<aside>
  <p><strong>Замечание:</strong> Нотация <code>{...}</code> будет интерпретирована как блочное выражение, а <strong>не</strong> как литерал объекта, если она не используется в присваивании, операторе <code>return</code> или в качестве функции. Это замечание, вкупе с <a href="#core.semicolon">автоматической расстановкой точек с запятой</a>, может привести к чрезвычайно изощрённым ошибкам.</p>
</aside>

<p>Также JavaScript не различает пространств имён: всё определяется на том или ином уровне в единственном <em>глобально доступном</em> пространстве имён.</p>

<p>Каждый раз, когда JavaScript обнаруживает ссылку на переменную, он будет искать её всё выше и выше по областям видимости, пока не найдёт её. В случае, если он достигнет глобальной области видимости и не найдет запрошенное имя и там тоже, он выбросит <code>ReferenceError</code>.</p>

</div><div><h3>Проклятие глобальных переменных</h3>

<pre><code>// скрипт A
foo = &#39;42&#39;;

// скрипт B
var foo = &#39;42&#39;
</code></pre>

<p>Вышеприведённые два скрипта отнюдь <strong>не</strong> приводят к одинаковому результату. Скрипт A определяет переменную по имени <code>foo</code> в <em>глобальной</em> области видимости, а скрипт B определяет <code>foo</code> в текущей области видимости.</p>

<p>Повторимся, это <strong>совсем не</strong> <em>тот же самый эффект</em>. Если вы не используете <code>var</code> — то вы в большой опасности.</p>

<pre><code>// глобальная область видимости
var foo = 42;
function test() {
    // локальная область видимости
    foo = 21;
}
test();
foo; // 21
</code></pre>

<p>Из-за того что оператор <code>var</code> был опущен внутри функции, фунция <code>test</code> перезапишет значение <code>foo</code>. Это поначалу может показаться не такой уж и большой проблемой, но если у вас имеется тысяча строк JavaScript-кода и вы не используете <code>var</code>, то вам на пути встретятся самые страшные и трудноотлаживаемые ошибки — и это не шутка.</p>

<pre><code>// глобальная область видимости
var items = [/* какой-то список */];
for(var i = 0; i &lt; 10; i++) {
    subLoop();
}

function subLoop() {
    // область видимости subLoop
    for(i = 0; i &lt; 10; i++) { // пропущен оператор var
        // происходят волшебные вещи!
    }
}
</code></pre>

<p>Внешний цикл прекратит работу сразу после первого вызова <code>subLoop</code>, поскольку <code>subLoop</code> перезаписывает глобальное значение переменной <code>i</code>. Использование <code>var</code> во втором цикле <code>for</code> могло бы вас легко избавить от этой ошибки. <strong>Никогда</strong> не забывайте использовать <code>var</code>, если только вы не <em>осознанно намеряны</em> повлиять на внешнюю область видимости.</p>

</div><div><h3>Локальные переменные</h3>

<p>Единственный источник локальных переменных в JavaScript - это параметры <a href="#function.general">функций</a> и переменные, объявленные с использованием оператора <code>var</code>.</p>

<pre><code>// глобальная область видимости
var foo = 1;
var bar = 2;
var i = 2;

function test(i) {
    // локальная область видимости для функции test
    i = 5;

    var foo = 3;
    bar = 4;
}
test(10);
</code></pre>

<p>В то время как <code>foo</code> и <code>i</code> — локальные переменные в области видимости функции <code>test</code>, присвоение <code>bar</code> переопределит значение одноимённой глобальной переменной.</p>

</div><div><h3>Вытягивание</h3>

<p>JavaScript <strong>«вытягивает»</strong> определения. Это значит, что оба определения с использованием <code>var</code> и определение <code>function</code> будут перенесены наверх из заключающей их области видимости.</p>

<pre><code>bar();
var bar = function() {};
var someValue = 42;

test();
function test(data) {
    if (false) {
        goo = 1;

    } else {
        var goo = 2;
    }
    for(var i = 0; i &lt; 100; i++) {
        var e = data[i];
    }
}
</code></pre>

<p>Этот код трансформируется ещё перед исполнением. JavaScript перемещает операторы <code>var</code> и определение <code>function</code> наверх ближайшей оборачивающей области видимости.</p>

<pre><code>// выражения с var переместились сюда
var bar, someValue; // по умолчанию - &#39;undefined&#39;

// определение функции тоже переместилось
function test(data) {
    var goo, i, e; // пропущенная блочная область видимости
                   // переместила их сюда
    if (false) {
        goo = 1;

    } else {
        goo = 2;
    }
    for(i = 0; i &lt; 100; i++) {
        e = data[i];
    }
}

bar(); // вылетает с ошибкой TypeError,
       // поскольку bar всё ещё &#39;undefined&#39;
someValue = 42; // присвоения не зависят от вытягивания
bar = function() {};

test();
</code></pre>

<p>Потерянная область видимости блока не только переместит операторы <code>var</code> вовне циклов и их тел, но и сделает результаты некоторых конструкций с <code>if</code> неинтуитивными.</p>

<p>Предполагалось, что в исходном коде оператор <code>if</code> изменял <em>глобальную переменную</em> <code>goo</code>, однако, как оказалось, он изменял <em>локальную переменную</em> — в результате работы вытягивания.</p>

<p>Если вы не знакомы с <em>вытягиваниями</em>, то можете предположить, что нижеприведённый код должен выбросить
<code>ReferenceError</code>.</p>

<pre><code>// проверить, проинициализована ли SomeImportantThing
if (!SomeImportantThing) {
    var SomeImportantThing = {};
}
</code></pre>

<p>Но конечно же этот код работает: из-за того, что оператор <code>var</code> был перемещён наверх <em>глобальной области видимости</em></p>

<pre><code>var SomeImportantThing;

// другой код может инициализировать здесь переменную SomeImportantThing,
// а может и нет

// убедиться, что она всё ещё здесь
if (!SomeImportantThing) {
    SomeImportantThing = {};
}
</code></pre>

</div><div><h3>Порядок разрешения имён</h3>

<p>Все области видимости в JavaScript, включая <em>глобальную область видимости</em>, содержат специальную, определённую внутри них, переменную <a href="#function.this"><code>this</code></a>, которая ссылается на <em>текущий объект</em>.</p>

<p>Области видимости функций также содержат внутри себя переменную <a href="#function.arguments"><code>arguments</code></a>, которая содержит аргументы, переданные в функцию.</p>

<p>Например, когда JavaScript пытается получить доступ к переменной <code>foo</code> в области видимости функции, он будет искать её по имени в такой последовательности:</p>

<ol>
<li>Если в текущей области видимости есть выражение <code>var foo</code>, использовать эту переменную.</li>
<li>Если один из параметров функции называется <code>foo</code>, использовать этот параметр.</li>
<li>Если функциия сама называется <code>foo</code>, использовать её.</li>
<li>Перейти на одну область видимости выше и повторить, начиная с <strong>п. 1</strong></li>
</ol>

<aside>
  <p><strong>Замечание:</strong> Наличие параметра функции с именем <code>arguments</code> <strong>не позволит</strong> движку создать объект <code>arguments</code>, создающийся, в других случаях, по умолчанию.</p>
</aside>

</div><div><h3>Пространства имён</h3>

<p>Нередкое обнаруживается неприятное последствие наличия одного единственного глобального пространства имён — проблемы с перекрытием имён переменных. В JavaScript эту проблему легко избежать, используя <em>анонимные обёртки</em>.</p>

<pre><code>(function() {
    // самодостаточное «пространство имён»

    window.foo = function() {
        // открытое замыкание
    };

})(); // сразу же выполнить функцию
</code></pre>

<p>Безымянные функции являются отложенными <a href="#function.general">выражениями</a> (&#39;&#39;прим. перев.&#39;&#39; — то есть, они не разбираются по месту описания, а откладываются парсером напоследок); поэтому, чтобы вы сделать их исполняемыми, следует спровоцировать их разбор.</p>

<pre><code>( // разобрать функцию внутри скобок
function() {}
) // и вернуть объект функции
() // вызвать результат разбора
</code></pre>

<p>Есть другие способы спровоцировать разбор и последующий вызов выражения с функцией; они, хоть и различаются в синтаксисе, действуют одинаково:</p>

<pre><code>// Два других способа
+function(){}();
(function(){}());
</code></pre>

<!--

> **На заметку:** &#39;&#39;прим. перев.&#39;&#39; в JavaScript кроме прочего существует конструкция `new function() {}`, она очень редко используется, но позволяет создать **новый экземпляр** анонимной функции. Например, если вы присваивате нескольким объектам одну и ту же анонимную функцию-конструктор, то `instanceof` перестаёт работать, здесь вам и поможет `new function()`.

-->

</div><div><h3>Заключение</h3>

<p>Рекомендуется всегда использовать <em>анонимную обёртку</em> чтобы заключить код в собственное пространство имён. Это не только защищает код от совпадений имён, но и позволяет создавать модульные программы.</p>

<p>Важно добавить, что использование глобальных переменных считается <strong>плохой практикой</strong>. <strong>Любое</strong> их использование демонстрирует плохое качество кода, предполагает его высокую подверженность ошибкам и сложность в его разборе.</p></div></article></section><section id="array"><!-- Introduction--><header id="array.intro"><h1>Массивы</h1></header><!-- Articles--><article id="array.general"><h2>Перебор массивов и свойств объектов</h2><div><p>Несмотря на то, что массивы в JavaScript являются объектами, достаточных оснований использовать <a href="#object.forinloop">цикл <code>for in</code></a> для перебора элементов массива <strong>не существует</strong>. Наоборот, существует достаточно хороших причин <strong>против</strong> использования <code>for in</code> с массивами.</p>

<aside>
  <p><strong>Замечание:</strong> Массивы в JavaScript <strong>не</strong> являются <em>ассоциативными массивами</em>. Для связывания ключей и значений в JavaScript есть только <a href="#object.general">объекты</a>. При этом, ассоциативные массивы априори <strong>сохраняют</strong> заданный порядок свойств, объекты же <strong>не</strong> делают этого.</p>
</aside>

<p>Поскольку во время выполнения <code>for in</code> циклически перебираются все свойства объекта, находящиеся в его цепочке прототипов, а единственный способ исключить ненужные свойства — использовать <a href="#object.hasownproperty"><code>hasOwnProperty</code></a> — такой цикл <strong>до 20 раз</strong> медленнее обычного цикла <code>for</code>.</p>

</div><div><h3>Итерирование</h3>

<p>Для достижения лучшей производительности при переборе массивов, лучше всего использовать обычный цикл <code>for</code>.</p>

<pre><code>var list = [1, 2, 3, 4, 5, ...... 100000000];
for(var i = 0, l = list.length; i &lt; l; i++) {
    console.log(list[i]);
}
</code></pre>

<p>В примере выше есть один дополнительный приём, с помощью которого кэшируется величина длины массива: <code>l = list.length</code>.</p>

<p>Несмотря на то, что свойство <code>length</code> определено в самом массиве, поиск этого свойства в объекте накладывает дополнительные расходы на каждой итерации цикла. Пусть в этом случае новые движки JavaScript и <strong>могут</strong> теоретически применить оптимизацию, всё же нет способа точно предугадать, будет оптимизирован код на новом движке или нет.</p>

<p>Фактически, цикл без кэширования может выполняться в <strong>два раза медленнее</strong>, нежели цикл с кэшированной длиной.</p>

<p>&#39;&#39;Прим. перев.&#39;&#39; — если вам нужно перебрать элементы в обратном порядке или порядок не имеет для вас значения, есть дополнительный способ (не самый быстрый, поскольку происходит сравнение без приведения типов) перебрать элементы массива: <code>var i = arr.length; while (i--) { ... }</code>.</p>

</div><div><h3>Свойство <code>length</code></h3>

<p>Хотя <em>геттер</em> свойства <code>length</code> всего лишь возвращает количество элементов содержащихся в массиве, <em>сеттер</em> оказывается удобно использовать для <strong>урезания</strong> массивов.</p>

<pre><code>var foo = [1, 2, 3, 4, 5, 6];
foo.length = 3;
foo; // [1, 2, 3]

foo.length = 6;
foo; // [1, 2, 3]
</code></pre>

<p>Присвоение свойству <code>length</code> меньшей величины урезает массив, однако присвоение большего значения не даёт никакого эффекта.</p>

</div><div><h3>Заключение</h3>

<p>Для оптимальной работы кода рекомендуется всегда использовать простой цикл <code>for</code> и кэшировать свойство <code>length</code>. Использование <code>for in</code> с массивами является признаком плохого кода, содержащего потенциальные ошибки, а также приводит к низкой скорости его выполнения.</p></div></article><article id="array.constructor"><h2>Конструктор <code>Array</code></h2><div><p>Так как конструктор <code>Array</code> не однозначен в плане вариантов перечисления его параметров, настоятельно рекомендуется при создании массивов всегда использовать синтаксис литеральной нотации — <code>[]</code>.</p>

<pre><code>[1, 2, 3]; // Результат: [1, 2, 3]
new Array(1, 2, 3); // Результат: [1, 2, 3]

[3]; // Результат: [3]
new Array(3); // Результат: []
new Array(&#39;3&#39;) // Результат: [&#39;3&#39;]
</code></pre>

<p>В случае, когда конструктору <code>Array</code> передаётся только один аргумент, и этот аргумент имеет тип <code>Number</code>, конструктор возвращает новый, <em>разреженный</em> (&#39;&#39;прим. перев.&#39;&#39; — <em>заполненный случайными значениями</em>), массив, имеющий длину, равную значению переданного аргумента. Стоит заметить, что таким образом будет установлено лишь свойство <code>length</code> нового массива, а реальные индексы массива не будут инициализированы.</p>

<pre><code>var arr = new Array(3);
arr[1]; // не определён, undefined
1 in arr; // false, индекс не был установлен
</code></pre>

<p>Поведение, которое позволяет заранее установить размер массива может пригодиться лишь в нескольких случаях — таких как повторение строки, за счёт которого избегается использование кода <code>for loop</code>.</p>

<pre><code>new Array(count + 1).join(stringToRepeat);
</code></pre>

</div><div><h3>Заключение</h3>

<p>Нужно избегать использования конструктора <code>Array</code>. Литералы, определённо, более предпочтительны — это краткая запись, она имеет более «чистый» синтаксис и повышает читабельность кода.</p></div></article></section><section id="types"><!-- Introduction--><header id="types.intro"><h1>Типы</h1></header><!-- Articles--><article id="types.equality"><h2>Равенство и сравнения</h2><div><p>JavaScript умеет сравнивать значения объектов на равенство двумя различными способами.</p>

</div><div><h3>Оператор сравнения</h3>

<p>Оператор сравнения состоит из <strong>двух</strong> символов равенства: <code>==</code></p>

<p>Под <em>слабой типизацией</em> языка JavaScript подразумевается <strong>приведение</strong> обеих переменных к <strong>одному типу</strong> при сравнении двух объектов.</p>

<pre><code>""           ==   "0"           // false
0            ==   ""            // true
0            ==   "0"           // true
false        ==   "false"       // false
false        ==   "0"           // true
false        ==   undefined     // false
false        ==   null          // false
null         ==   undefined     // true
" \t\r\n"    ==   0             // true
</code></pre>

<p>В таблице выше показаны результаты приведения типов в разных ситуациях и показана главная причина, по которой использование <code>==</code> повсеместно считается плохой практикой: благодаря непредсказуемости правил преобразования типов, оказывается трудно искать причины возникновения ошибок.</p>

<p>Кроме того, приведение типов во время сравнения вынужденно влияет на производительность; например, строка должна быть преобразована в число перед сравнением с другим числом.</p>

</div><div><h3>Оператор строгого равенства</h3>

<p>Оператор строгого равенства состоит из <strong>трёх</strong> символов равенства: <code>===</code></p>

<p>Он работает также как и обычный оператор сравнения, но оператор строгого равенства <strong>не</strong> выполняет приведения типов между своими операндами.</p>

<pre><code>""           ===   "0"           // false
0            ===   ""            // false
0            ===   "0"           // false
false        ===   "false"       // false
false        ===   "0"           // false
false        ===   undefined     // false
false        ===   null          // false
null         ===   undefined     // false
" \t\r\n"    ===   0             // false
</code></pre>

<p>Результаты выше немного более предсказуемы и помогают быстрее выявлять ошибки в коде. Использование этого оператора в определённой степени делает код надёжнее, а кроме того обспечивает прирост производительности в случае, если типы операндов различны.</p>

</div><div><h3>Сравнение объектов</h3>

<p>Хотя оба оператора <code>==</code> и <code>===</code> заявлены как операторы равенства, они ведут себя по-разному, когда хотя бы одним из операндов оказывается <code>Object</code>.</p>

<pre><code>{} === {};                   // false
new String(&#39;foo&#39;) === &#39;foo&#39;; // false
new Number(10) === 10;       // false
var foo = {};
foo === foo;                 // true
</code></pre>

<p>Здесь оба операнда сравниваются на <strong>идентичность</strong>, а <strong>не</strong> на равенство; то есть, будет проверяться, являются ли операнды одним и тем же <strong>экземпляром</strong> объекта, так же как делает <code>is</code> в Python или сравниваются указатели в С.</p>

</div><div><h3>Заключение</h3>

<p>Крайне рекомендуется использовать только операторы <strong>строгого равенства</strong>. В случаях, когда необходимо использовать преобразование типов, нужно сделать <a href="#types.casting">явное приведение</a>, а не оставлять его на совести нарочито мудрых языковых операций.</p></div></article><article id="types.typeof"><h2>Оператор <code>typeof</code></h2><div><p>Оператор <code>typeof</code> (вместе с <a href="#types.instanceof"><code>instanceof</code></a>) — это, вероятно, самая большая недоделка в JavaScript, поскольку с накоплением опыта выясняется, что он <strong>поломан, разве что не полностью</strong>.</p>

<p>При том, число поводов для применения <code>instanceof</code> ограничено, <code>typeof</code> вообще имеет <em>один-единственный</em> практический случай применения, который при всём при этом, неожиданно,.. <strong>не</strong> оказывается проверкой типа объекта.</p>

<aside>
  <p><strong>Замечаение:</strong> Хотя для вызова <code>typeof</code> также можно использовать синтаксис функции, т.е. <code>typeof(obj)</code>, на самом деле это вовсе не функция. Да — двойные круглые скобки будут работать нормально и возвращаемое значение будет использоваться как операнд оператора <code>typeof</code>, но функции <code>typeof</code> — <strong>не существует</strong>.</p>
</aside>

</div><div><h3>Таблица типов JavaScript</h3>

<pre><code>Значение            Класс      Тип
-------------------------------------
"foo"               String     string
new String("foo")   String     object
1.2                 Number     number
new Number(1.2)     Number     object
true                Boolean    boolean
new Boolean(true)   Boolean    object
new Date()          Date       object
new Error()         Error      object
[1,2,3]             Array      object
new Array(1, 2, 3)  Array      object
new Function("")    Function   function
/abc/g              RegExp     object (function в Nitro/V8)
new RegExp("meow")  RegExp     object (function в Nitro/V8)
{}                  Object     object
new Object()        Object     object
</code></pre>

<p>В этой таблице в колонке <em>Тип</em> приводится значение, возвращаемое оператором <code>typeof</code> для указанного объекта. Как хорошо заметно, это значение может оказаться чем угодно, но не ожидавшимся результатом.</p>

<p>В колонке <em>Класс</em> приведено значение внутреннего свойства объекта <code>[[Class]]</code>.</p>

<aside>
  <p><strong>Из спецификации:</strong> Значением <code>[[Class]]</code> может быть одна из следующих строк: <code>Arguments</code>, <code>Array</code>, <code>Boolean</code>, <code>Date</code>, <code>Error</code>, <code>Function</code>, <code>JSON</code>, <code>Math</code>, <code>Number</code>, <code>Object</code>, <code>RegExp</code>, <code>String</code>.</p>
</aside>

<p>Чтобы получить значение <code>[[Class]]</code>, нужно применить к интересующему объекту метод <code>toString</code> из прототипа <code>Object.prototype</code>. (&#39;&#39;прим. перев.&#39;&#39; — то есть не вызвать метод у самого объекта, а именно применить к нему метод из прототипа, см. ниже).</p>

</div><div><h3>Класс объекта</h3>

<p>Спецификация предоставляет только один способ доступа к значению <code>[[Class]]</code> — используя <code>Object.prototype.toString</code>.</p>

<pre><code>function is(type, obj) {
    var clas = Object.prototype.toString.call(obj).slice(8, -1);
    return obj !== undefined &amp;&amp; obj !== null &amp;&amp; clas === type;
}

is(&#39;String&#39;, &#39;test&#39;); // true
is(&#39;String&#39;, new String(&#39;test&#39;)); // true
</code></pre>

<p>В примере выше <code>Object.prototype.toString</code> вызывается со значением <a href="#function.this">this</a>, ссылающимся на объект, значение <code>[[Class]]</code> которого требуется получить.</p>

<aside class="es5"><p><strong>ES5 Замечание:</strong> Для удобства, в ECMAScript 5 возвращаемое значение <code>Object.prototype.toString</code> для <code>null</code> и <code>undefined</code> было изменено с <code>Object</code> на <code>Null</code> и <code>Undefined</code> соответственно.</p>
</aside>

</div><div><h3>Проверка переменных на определённость</h3>

<pre><code>typeof foo !== &#39;undefined&#39;
</code></pre>

<p>Данное выражение позволяет удостовериться, была ли объявлена переменная <code>foo</code>; явное обращение к несуществующей переменной в коде породит <code>ReferenceError</code>. И вот это — единственное, чем на самом деле полезен <code>typeof</code>.</p>

</div><div><h3>Заключение</h3>

<p>Для проверки типа объекта настоятельно рекомендуется использовать <code>Object.prototype.toString</code> — это единственный и надежный способ. Как показано выше в таблице типов, некоторые значения, возвращаемые <code>typeof</code>, не описаны в спецификации: следовательно, они могут различаться в разных реализациях движка.</p>

<p>За исключением случаев проверки, была ли определена переменная, использования <code>typeof</code> следует избегать.</p></div></article><article id="types.instanceof"><h2>Оператор <code>instanceof</code></h2><div><p>Оператор <code>instanceof</code> сравнивает конструкторы двух операндов. Работает это только тогда, когда сравниваются пользовательские объекты. Использование же на встроенных типах почти так же бесполезно, как и <a href="#types.typeof">оператор typeof</a>.</p>

</div><div><h3>Сравнение пользовательских объектов</h3>

<pre><code>function Foo() {}
function Bar() {}
Bar.prototype = new Foo();

new Bar() instanceof Bar; // true
new Bar() instanceof Foo; // true

// Банально присваиваем Bar.prototype объект функции Foo,
// но не экземпляра Foo
Bar.prototype = Foo;
new Bar() instanceof Foo; // false
</code></pre>

</div><div><h3>Использование <code>instanceof</code> со встроенными типами</h3>

<pre><code>new String(&#39;foo&#39;) instanceof String; // true
new String(&#39;foo&#39;) instanceof Object; // true

&#39;foo&#39; instanceof String; // false
&#39;foo&#39; instanceof Object; // false
</code></pre>

<p>Здесь надо отметить одну важную вещь: <code>instanceof</code> не работает на объектах, которые происходят из разных контекстов JavaScript (например, из различных документов в web-браузере), так как их конструкторы и правда не будут конструкторами <em>тех же самых</em> объектов.</p>

</div><div><h3>Заключение</h3>

<p>Оператор <code>instanceof</code> должен использоваться <strong>только</strong> при обращении к пользовательским объектам, происходящим из одного контекста JavaScript. Так же, как и в случае оператора <code>typeof</code>, любого другого использования <code>instanceof</code> необходимо <strong>избегать</strong>.</p></div></article><article id="types.casting"><h2>Приведение типов</h2><div><p>JavaScript — язык, в котором господствует <em>слабая типизация</em>, поэтому <em>преобразование типов</em> будет применяться <strong>везде</strong>, где только возможно.</p>

<pre><code>// Эти равенства возвращают true
new Number(10) == 10; // Number.toString() преобразуется
                      // обратно в число

10 == &#39;10&#39;;           // Строки преобразуются в Number
10 == &#39;+10 &#39;;         // Ещё чуток строко-безумия
10 == &#39;010&#39;;          // и ещё
isNaN(null) == false; // null преобразуется в 0,
                      // который, конечно же, не NaN

// Эти равенства возвращают false
10 == 010;
10 == &#39;-10&#39;;
</code></pre>

<aside class="es5"><p><strong>ES5 Замечание:</strong> Числовые литералы, которые начинаются с 0 интерпретируются как восьмеричные (Base 8). В ECMAScript 5 strict mode <strong>удалена</strong> поддержка восьмеричной системы.</p>
</aside>

<p>Для того, чтобы избежать такого поведения, <strong>настоятельно</strong> рекомендуется использовать <a href="#types.equality">оператор строгого равенства</a>. Впрочем, хотя это и позволяет избежать многих распространенных ошибок, существует ещё много дополнительных проблем, возникающих по вине слабой типизации JavaScript.</p>

</div><div><h3>Конструкторы встроенных типов</h3>

<p>Конструкторы встроенных типов, например, <code>Number</code> и <code>String</code> ведут себя различным образом, в зависимости от того, вызываются они с ключевым словом <code>new</code> или без.</p>

<pre><code>new Number(10) === 10;     // False: Object и Number
Number(10) === 10;         // True: Number и Number
new Number(10) + 0 === 10; // True: из-за неявного преобразования
</code></pre>

<p>Использование встроенных типов, таких как <code>Number</code>, с конструктором, создаёт новый экземпляр объекта <code>Number</code>, но использование без ключевого слова <code>new</code> создаёт функцию <code>Number</code>, которая будет вести себя в равенствах как конвертер.</p>

<p>Кроме того, присутствие в равенствах литералов или переменных, которые не являются объектами, повлечёт лишь более серьёзное насилие над типами.</p>

<p>Лучший вариант — это <strong>явное</strong> приведение к одному из трех возможных типов.</p>

</div><div><h3>Приведение к строке</h3>

<pre><code>&#39;&#39; + 10 === &#39;10&#39;; // true
</code></pre>

<p>Путём добавления в начале пустой строки, значение легко приводится к строке.</p>

</div><div><h3>Приведение к числовому типу</h3>

<pre><code>+&#39;10&#39; === 10; // true
</code></pre>

<p>Используя <strong>унарный</strong> оператор плюс, можно преобразовать значение в число.</p>

</div><div><h3>Приведение к булеву типу</h3>

<p>Использование оператора <strong>not</strong> (<code>!</code>) дважды поможет привести значение к логическому (булеву) типу.</p>

<pre><code>!!&#39;foo&#39;;   // true
!!&#39;&#39;;      // false
!!&#39;0&#39;;     // true
!!&#39;1&#39;;     // true
!!&#39;-1&#39;     // true
!!{};      // true
!!true;    // true
</code></pre></div></article></section><section id="core"><!-- Introduction--><header id="core.intro"><h1>Ядро</h1></header><!-- Articles--><article id="core.eval"><h2>Почему нельзя использовать <code>eval</code></h2><div><p>Функция <code>eval</code> исполняет хранящийся в строке код JavaScript в локальной области видимости.</p>

<pre><code>var foo = 1;
function test() {
    var foo = 2;
    eval(&#39;foo = 3&#39;);
    return foo;
}
test(); // 3
foo; // 1
</code></pre>

<p>Однако, <code>eval</code> исполняется в локальной области видимости тогда и только тогда, когда он вызывается явно <em>и при этом</em> имя вызывающейся функции идентично <code>eval</code> (&#39;&#39;прим. перев.&#39;&#39; — ох!).</p>

<pre><code>var foo = 1;
function test() {
    var foo = 2;
    var bar = eval;
    bar(&#39;foo = 3&#39;);
    return foo;
}
test(); // 2
foo; // 3
</code></pre>

<p><strong>Любой ценой</strong> избегайте использования функции <code>eval</code>. 99.9% «трюков» с её «использованием» могут легко решаться и <strong>без её участия</strong>.</p>

</div><div><h3><code>eval</code> под прикрытием</h3>

<p>Обе <a href="#other.timeouts">функции работы с интервалами времени</a> <code>setTimeout</code> и <code>setInterval</code> могут принимать строку в качестве первого аргумента. Эта строка <strong>всегда</strong> будет выполняться в глобальной области видимости, поскольку <code>eval</code> в этом случае вызывается <em>неявно</em>.</p>

</div><div><h3>Проблемы с безопасностью</h3>

<p>Кроме всего прочего, функция <code>eval</code> — это проблема в безопасности, поскольку она выполняет <strong>любой</strong> переданный в неё код; <strong>никогда</strong> не следует использовать её со строками из неизвестных или недоверительных источников.</p>

</div><div><h3>Заключение</h3>

<p>Использовать <code>eval</code> не стоит никогда: любой код с участием этой функции автоматически порождает вопросы о качестве его работы, производительности и безопасности. Если вдруг для работы вам необходим <code>eval</code>, эта часть кода должна тут же ставиться под сомнение и в первую очередь <em>исключаться</em>* из проекта — необходимо найти <em>лучший способ</em>, которому не требуются вызовы <code>eval</code>.</p></div></article><article id="core.undefined"><h2><code>undefined</code> и <code>null</code></h2><div><p>В JavaScript есть два отдельных типа для описания <em>ничего</em> — <code>null</code> и <code>undefined</code>, при этом последний из них более полезен.</p>

</div><div><h3>Значение <code>undefined</code></h3>

<p><code>undefined</code> — это тип с единственным возможным значением: <code>undefined</code>.</p>

<p>Кроме этого, в языке определена глобальная переменная со значением <code>undefined</code>, причём эта переменная так и называется — <code>undefined</code>. Не являясь константой, она не является и ключевым словом. Из этого следует, что её значение можно с лёгкостью переопределить.</p>

<aside class="es5"><p><strong>ES5 Замечание:</strong> в ECMAScript 5 переменная <code>undefined</code> <strong>уже не</strong> <em>доступна на запись</em> в strict-режиме, однако она всё так же может быть перегружена по имени, например - функцией с именем <code>undefined</code>.</p>
</aside>

<p>Список случаев, когда код возвращает значение <code>undefined</code>:</p>

<ul>
<li>При попытке доступа к глобальной переменной <code>undefined</code> (если она не была переопределена).</li>
<li>При попытке доступа к переменной, которая <em>ещё не была</em> инициализирована каким-либо значением.</li>
<li>Неявный возврат из функции при отсутствии в ней оператора <code>return</code>.</li>
<li>Из оператора <code>return</code>, который не возвращает явного значения.</li>
<li>В результате поиска несуществующего свойства у объекта (и/или доступа к нему).</li>
<li>При попытке доступа к аргументу функции, который не был передан в неё явно.</li>
<li>При попытке доступа ко всему, чьим значением является <code>undefined</code>.</li>
<li>В результате вычисления любого выражения, соответствующего форме <code>void(выражение)</code>.</li>
</ul>

</div><div><h3>Защита от потенциальных изменений значения <code>undefined</code></h3>

<p>Поскольку глобальная переменная <code>undefined</code> содержит копию реального <em>значения</em> <code>undefined</code>, присвоение этой переменной нового значения <strong>не</strong> изменяет значения у <em>типа</em> <code>undefined</code>.</p>

<p>Получается, чтобы проверить нечто с типом <code>undefined</code> на соответствие значению <code>undefined</code>, прежде нужно узнать изначальное значение переменной <code>undefined</code>.</p>

<p>Чтобы защитить код от переопределения переменной <code>undefined</code>, часто используют технику <a href="#function.scopes">анонимной обёртки</a>, в которую добавляют аргумент и намеренно не передают его значение.</p>

<pre><code>var undefined = 123;
(function(something, foo, undefined) {
    // в локальной области видимости `undefined`
    // снова ссылается на правильное значене.

})(&#39;Hello World&#39;, 42);
</code></pre>

<p>Другой способ достичь того же эффекта — использовать определение внутри обёртки.</p>

<pre><code>var undefined = 123;
(function(something, foo) {
    var undefined;
    ...

})(&#39;Hello World&#39;, 42);
</code></pre>

<p>Единственная разница между этими вариантами в том, что последняя версия будет больше на 4 байта при минификации, и в первом случае внутри анонимной обёртки нет дополнительного оператора <code>var</code>.</p>

</div><div><h3>Применение <code>null</code></h3>

<p>Хотя <code>undefined</code> в контексте языка JavaScript чаще используется в роли традиционного <em>null</em>, настоящий <code>null</code> (и тип и литерал) является, в некоторой степени, просто другим типом данных.</p>

<p>Он используется во внутренних механизмах JavaScript (в случаях вроде установки конца цепочки прототипов через присваивание <code>Foo.prototype = null</code>). Но почти во всех случаях тип <code>null</code> может быть заменён на <code>undefined</code>.</p></div></article><article id="core.semicolon"><h2>Автоматическая вставка точек с запятой</h2><div><p>Несмотря на то, что JavaScript имеет синтаксис, подобный языкам семейства C, он никоим образом <strong>не принуждает</strong> вас ставить точки с запятой в исходном коде — вы всегда вольны их опустить.</p>

<p>При этом JavaScript — вовсе не язык с полным отсутствием точек с запятой: они на самом деле нужны ему для того, чтобы он мог разобраться в вашем коде. Поэтому парсер JavaScript <strong>автоматически</strong> вставляет их в те места, где сталкивается с ошибкой парсинга по причине их отсутствия.</p>

<pre><code>var foo = function() {
} // ошибка разбора, ожидается точка с запятой
test()
</code></pre>

<p>Происходит вставка и парсер пытается снова.</p>

<pre><code>var foo = function() {
}; // ошибки нет, парсер продолжает
test()
</code></pre>

<p>Автоматическая вставка точек с запятой считается одним из <strong>наибольших</strong> упущений в проекте языка, поскольку она <em>действительно может</em> влиять на поведение кода.</p>

</div><div><h3>Как это работает</h3>

<p>Приведённый код не содержит точек с запятой, так что места для их вставки остаются на совести парсера:</p>

<pre><code>(function(window, undefined) {
    function test(options) {
        log(&#39;проверяем!&#39;)

        (options.list || []).forEach(function(i) {

        })

        options.value.test(
            &#39;здесь передадим длинную строчку&#39;,
            &#39;и ещё одну на всякий случай&#39;
        )

        return
        {
            foo: function() {}
        }
    }
    window.test = test

})(window)

(function(window) {
    window.someLibrary = {}

})(window)
</code></pre>

<p>Ниже представлен результат игры парсера в «угадалки».</p>

<pre><code>(function(window, undefined) {
    function test(options) {

        // не вставлена точка с запятой, строки были объединены
        log(&#39;тестируем!&#39;)(options.list || []).forEach(function(i) {

        }); // &lt;- вставлена

        options.value.test(
            &#39;здесь передадим длинную строчку&#39;,
            &#39;и ещё одну на всякий случай&#39;
        ); // &lt;- вставлена

        return; // &lt;- вставлена, в результате
                //    оператор return разбит на два блока
        { // теперь парсер считает этот блок отдельным

            // метка и одинокое выражение
            foo: function() {}
        }; // &lt;- вставлена
    }
    window.test = test; // &lt;- вставлена

// снова объединились строки
})(window)(function(window) {
    window.someLibrary = {}; // &lt;- вставлена

})(window); //&lt;- вставлена
</code></pre>

<aside>
  <p><strong>Замечание:</strong> Парсер JavaScript некорректно обрабатывает оператор <code>return</code>, за которым следует новая строка; Причина может быть и не в автоматической вставке точек с запятой, но без сомнений, это нежелательный побочный эффект.</p>
</aside>

<p>Парсер радикально поменял поведение изначального кода, а в определённых случаях он вообще сделал <strong>абсолютно неправильные выводы</strong>.</p>

</div><div><h3>«Висящие» скобки</h3>

<p>Если парсер встречает «висящую» открывающую скобку, то он <strong>не</strong> вставляет точку с запятой.</p>

<pre><code>log(&#39;тестируем!&#39;)
(options.list || []).forEach(function(i) {})
</code></pre>

<p>Такой код трасформируется в одну склеенную строку.</p>

<pre><code>log(&#39;тестируем!&#39;)(options.list || []).forEach(function(i) {})
</code></pre>

<p><strong>Чрезвычайно</strong> высоки шансы, что <code>log</code> <strong>не</strong> возращает <em>никаких</em> функций; таким образом, выполнение кода с такой строкой породит <code>TypeError</code> с сообщением о том, что <code>undefined не является функцией</code>.</p>

</div><div><h3>Заключение</h3>

<p>Настоятельно рекомендуем <strong>никогда</strong> не забывать ставить точку с запятой; также рекомендуется оставлять скобки на одной строке с соответствующим оператором и никогда не опускать их для выражений с использованием <code>if</code> / <code>else</code>. Оба этих совета не только повысят читабельность вашего кода, но и предотвратят от изменения поведения кода, произведённого парсером втихую.</p></div></article></section><section id="other"><!-- Introduction--><header id="other.intro"><h1>Другое</h1></header><!-- Articles--><article id="other.timeouts"><h2><code>setTimeout</code> и <code>setInterval</code></h2><div><p>В виду того, что JavaScript умеет совершать асинхронные операции, есть возможность запланировать отложенное выполнение пользовательской функции, используя предназначенные для этого функции <code>setTimeout</code> и <code>setInterval</code>.</p>

<aside>
  <p><strong>Замечание:</strong> Таймауты <strong>не</strong> являются частью стандарта ECMAScript, они были разработаны будучи частью спецификации<a href="http://ru.wikipedia.org/wiki/Document_Object_Model" title="Document Object Model">DOM</a>.</p>
</aside>

<pre><code>function foo() {}
var id = setTimeout(foo, 1000); // возвращает число &gt; 0
</code></pre>

<p>Функция <code>setTimeout</code> возвращает идентификатор назначенного таймаута и откладывает вызов <code>foo</code> на, <strong>примерно</strong>, тысячу миллисекунд. Фунция <code>foo</code>, при этом, будет вызвана только <strong>один</strong> раз.</p>

<p>В зависимости от разрешения таймера в используемом для запуска кода движке JavaScript, а также с учётом того, что JavaScript является однопоточным языком и посторонний код может заблокировать выполнение потока, нет <strong>никакой</strong> гарантии, что переданный код будет выполнен ровно через указанное в вызове <code>setTimeout</code> время.</p>

<p>Функция, переданная первым параметром, будет вызвана в контексте <em>глобального объекта</em> — это значит, что оператор <a href="#function.this"><code>this</code></a> в вызываемой функции будет ссылаться на тот самый глобальный объект.</p>

<pre><code>function Foo() {
    this.value = 42;
    this.method = function() {
        // this ссылается на глобальный объект
        console.log(this.value); // выведет в лог undefined
    };
    setTimeout(this.method, 500);
}
new Foo();
</code></pre>

<aside>
  <p><strong>Замечание:</strong> Поскольку <code>setTimeout</code> принимает <strong>объект функции</strong> в качестве первого параметра, часто совершается ошибка в использовании <code>setTimeout(foo(), 1000)</code>, при котором будет использоваться <strong>возвращённое значение</strong> от вызова функции <code>foo</code>, а <strong>не</strong> вызываться сама функция <code>foo</code>. В большинстве случаев ошибка пройдёт незамеченной, а в случае если функция возвращает <code>undefined</code>, <code>setTimeout</code> вообще <strong>не</strong> породит никакой ошибки.</p>
</aside>

</div><div><h3>Очереди вызовов с <code>setInterval</code></h3>

<p><code>setTimeout</code> вызывает функцию единожды; <code>setInterval</code> — как и предполагает название — вызывает функцию <strong>каждые</strong> <code>X</code> миллисекунд. И использовать его не рекомендуется.</p>

<p>В то время как, если применять <code>setTimeout</code>, исполняющийся в данный момент код будет блокировать запланированный — <code>setInterval</code> будет продолжать планировать последующие вызовы переданной функции. Это может, особенно при указании небольших интервалов, повлечь за собой выстраивание функций в ожидающую очередь.</p>

<pre><code>function foo(){
    // что-то, выполняющееся одну секунду или более
}
setInterval(foo, 1000);
</code></pre>

<p>В приведённом примере <code>foo</code> в первый же раз заблокирует своим процессом главный поток на одну секунду.</p>

<p>Пока <code>foo</code> блокирует код, <code>setInterval</code> продолжает планировать последующие её вызовы. Теперь, когда первая <code>foo</code> закончила выполнение, в очереди будут уже <strong>десять</strong> ожидающих выполнения вызовов <code>foo</code>.</p>

</div><div><h3>Разбираемся с потенциальной блокировкой кода</h3>

<p>Самый простой и наиболее легко контролируемый способ — использовать <code>setTimeout</code> внутри такой функции.</p>

<pre><code>function foo(){
    // что-то, выполняющееся одну секунду или более
    setTimeout(foo, 1000);
}
foo();
</code></pre>

<p>Такой способ не только инкапсулирует вызов <code>setTimeout</code>, но и предотвращает от очередей блокирующих вызовов и при этом обеспечивает дополнительный контроль. Сама функция <code>foo</code> теперь принимает решение, хочет ли она запускаться ещё раз или нет.</p>

<p>(&#39;&#39;прим. перев.&#39;&#39; — такая техника теперь активно используется при использовании браузерного метода <code>requestAnimationFrame</code> для анимации, работающей на <code>canvas</code>).</p>

</div><div><h3>Сброс таймаутов вручную</h3>

<p>Удалить таймаут или интервал можно посредством передачи соответствующего идентификатора либо в функцию <code>clearTimeout</code>, либо в функцию <code>clearInterval</code> — в зависимости от того, какая функция <code>set...</code> использовалась для его создания.</p>

<pre><code>var id = setTimeout(foo, 1000);
clearTimeout(id);
</code></pre>

</div><div><h3>Сброс всех таймаутов</h3>

<p>Из-за того, что встроенного метода для удаления всех созданных таймаутов и/или интервалов не существует, для успешного достижения этой цели приходится использовать силу.</p>

<pre><code>// сбрасываем «все» таймауты
for(var i = 1; i &lt; 1000; i++) {
    clearTimeout(i);
}
</code></pre>

<p>Впрочем, с таким кодом, вполне могут остаться «живыми» таймауты, которые не окажутся охвачены настолько произвольным числом.</p>

<p>Есть и другой способ воплотить желаемое — условиться, что значения ID, выдающихся таймаутам, постоянно увеличиваются — с каждым новыми вызовом <code>setTimeout</code>.</p>

<pre><code>// сбрасываем «все» таймауты
var biggestTimeoutId = window.setTimeout(function(){}, 1),
i;
for(i = 1; i &lt;= biggestTimeoutId; i++) {
    clearTimeout(i);
}
</code></pre>

<p>Однако, даже при том, что такой код работает сегодня во всех современных браузерах, нигде не указано и не гарантируется, что значения ID всегда увеличиваются. Поэтому, всё же, рекомендуется следить за <em>каждым</em> идентификатором <em>каждого</em> создающегося таймаута —  это позволит вам надёжно контролировать процесс, сбрасывая их индивидуально.</p>

</div><div><h3>Скрытое использование <code>eval</code></h3>

<p><code>setTimeout</code> и <code>setInterval</code> могут принимать строку в качестве первого параметра. Эту возможность не стоит использовать <strong>никогда</strong>, поскольку изнутри, при этом, производится скрытый вызов <code>eval</code>.</p>

<aside>
  <p><strong>Замечание</strong>: Поскольку функции работы с таймаутами <strong>не</strong> определены в стандарте ECMAScript, точная внутренняя механика их работы может различаться от движка к движку. Например, Microsoft JScript использует конструктор <code>Function</code> вместо <code>eval</code>.</p>
</aside>

<pre><code>function foo() {
    // будет вызвана
}

function bar() {
    function foo() {
        // никогда не будет вызывана
    }
    setTimeout(&#39;foo()&#39;, 1000);
}
bar();
</code></pre>

<p>Поскольку <code>eval</code> в этом случае не вызывается <a href="#core.eval">явно</a>, переданная в <code>setTimeout</code> строка будет выполнена в <em>глобальной области видимости</em>; так что локальная функция <code>foo</code> из области видимости <code>bar</code> вообще не будет выполнена.</p>

<p>По этим же причинам <strong>не рекомендуется</strong> использовать строковое представление вызова функции для передачи аргументов в функцию, которая должна быть вызвана посредством любого из двух известных способов назначения таймаутов.</p>

<pre><code>function foo(a, b, c) {}

// НИКОГДА не делайте такого
setTimeout(&#39;foo(1,2, 3)&#39;, 1000)

// Вместо этого используйте анонимную функцию
setTimeout(function() {
    foo(a, b, c);
}, 1000)
</code></pre>

<aside>
  <p><strong>Замечание:</strong> При том, что практически возможно использовать синтаксис <code>setTimeout(foo, 1000, a, b, c)</code>, делать это крайне не рекомендуется, поскольку может привести к трудно-отлавливаемым ошибкам при операциях с <a href="#function.this">методами</a>.</p>
</aside>

</div><div><h3>Заключение</h3>

<p><strong>Никогда</strong> не используйте строки как параметры для <code>setTimeout</code> или <code>setInterval</code>. Это явный признак <strong>действительно</strong> плохого кода. Если вызываемой функции необходимо передавать аргументы, лучше передавать <em>анонимную функцию</em>, которая самостоятельно будет отвечать за сам вызов.</p>

<p>Кроме прочего, избегайте использования <code>setInterval</code> в случаях, когда его планировщик может заблокировать выполнение основного кода JavaScript.</p></div></article></section><section id="appendix"><!-- Introduction--><header id="appendix.intro"><h1>Пояснения</h1></header><!-- Articles--><article id="appendix.fromtranslators"><h2>От переводчиков</h2><div><p>Авторы этой документации требуют от читателя не совершать каких-либо ошибок и постоянно следить за качеством пишущегося кода. Мы, как переводчики и опытные программисты на JavaScript рекомендуем <em>прислушиваться</em> к этим советам, но при этом не делать из этого <em>крайность</em>. Опыт — сын ошибок трудных, и иногда в борьбе с ошибками зарождается намного более детальное понимание предмета. Да, нужно избегать ошибок, но допускать их неосознанно — вполне нормально.</p>

<p>К примеру, в статье про <a href="#types.equality">сравнение объектов</a> авторы настоятельно рекомендуют использовать <em>только</em> оператор строгого неравенства <code>===</code>. Но мы считаем, что если вы уверены и осознали, что оба сравниваемых операнда имеют один тип, вы имеете право опустить последний символ <code>=</code>. Вы вольны применять строгое неравенство только в случаях, когда вы не уверены в типах операндов (<code>!== undefined</code> — это полезный приём). Так в вашем коде будут опасные и безопасные области, но при этом по коду будет явно видно, где вы рассчитываете на переменные одинаковых типов, а где позволяете пользователю вольности.</p>

<p>Функцию <a href="#other.timeouts"><code>setInterval</code></a> тоже можно использовать, если вы стопроцентно уверены, что код внутри неё будет исполняться как минимум в три раза быстрее переданного ей интервала.</p>

<p>С другой стороны, <a href="#function.scopes">использование <code>var</code></a> и грамотная <a href="#core.semicolon">расстановка точек с запятой</a> — обязательные вещи, халатное отношение к которым никак не может быть оправдано — в осознанном пропуске <code>var</code> (если только вы не переопределяете глобальный объект браузера... хотя <em>зачем</em>?) или точки с запятой нет никакого смысла.</p>

<p>Относитесь с <strong>мудростью</strong> к тому, что вы пишете — <em>важно</em> знать как работает именно ваш код и как это соответствует приведённым в статье тезисам — и уже из этого вы сможете делать вывод, подходит ли вам тот или иной подход или нет. <em>Важно</em> знать как работает <a href="#object.prototype">прототипное наследование</a>, но это не так необходимо, если вы используете функциональный подход или пользуетесь какой-либо сторонней библиотекой. Важно помнить о том, что у вас недостаёт какого-либо конкретного знания и что пробел следует заполнить, но если вы не используете в работе эту часть, вы всё равно можете писать хороший код — ну, если у вас есть талант.</p>

<p>Гонка за оптимизацией — это драматично и правильно, но лучше написать работающий и понятный вам код, а потом уже его оптимизировать и искать узкие места, при необходимости. Оптимизацию необходимо делать, если вы видите явные неудобства для пользователя в тех или иных браузерах или у вас есть супер-крупный проект, которым никогда не мешает оптимизация, или вы работаете с какой-либо сверхтребовательной технологией типа WebGL. Данная документация очень поможет вам в определении этих узких мест.</p></div></article></section><!-- Footer--><footer><p>Copyright &copy; 2011. Built with 
<a href="http://nodejs.org/">Node.js </a>using a
<a href="https://github.com/visionmedia/jade/">jade </a>template. 
Hosted by 
<a href="http://cramerdev.com">Cramer Development</a>.
</p></footer><script src="http://ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script><script src="javascript/prettify.js"></script><script src="javascript/plugin.js"></script><script src="javascript/garden.js"></script></body></html>